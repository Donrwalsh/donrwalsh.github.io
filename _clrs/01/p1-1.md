---
layout: clrs-solution
title:  "Problem 1-1"
---
**For each function *f(n)* and time *t* in the following table, determine the largest size *n* of a problem that can be solved in time *t*, assuming that the algorithm to solve the problem takes *f(n)* microseconds.**

I wrote `running_time_compare.py` to solve this table. The numbers got pretty big, so I used some techniques to simplify the figures. 

| | 1 second | 1 minute | 1 hour | 1 day | 1 month | 1 year | 1 century
| - | - | - | - | - | - | - | - |
| lg *n* | 2<sup>10<sup>6</sup></sup> | 2<sup>6*10<sup>7</sup></sup> | 2<sup>3.6*10<sup>9</sup></sup> | 2<sup>8.64*10<sup>10</sup></sup> | 2<sup>2.59*10<sup>12</sup></sup> | 2<sup>3.15*10<sup>13</sup></sup> | 2<sup>3.15*10<sup>15</sup></sup>
| sqrt(*n*) | 10<sup>12</sup> | 3.6*10<sup>15</sup> | 1.3*10<sup>19</sup> | 7.47*10<sup>21</sup> | 6.72*10<sup>24</sup> | 9.95*10<sup>26</sup> | 9.96*10<sup>30</sup>
| *n* | 10<sup>6</sup> | 6*10<sup>7</sup> | 3.6*10<sup>9</sup> | 8.64*10<sup>10</sup> | 2.6*10<sup>12</sup> | 3.15*10<sup>13</sup> | 3.15*10<sup>15</sup>
| *n* lg *n* | 62,746 | 2,801,417 | 133,378,058 | 2,755,147,513 | 71,870,856,404 | 797,633,893,349 | 68,610,956,750,570
| n<sup>2</sup> | 1,000 | 7,745 | 60,000 | 293,398 | 1,609,968 | 5,615,692 | 56,156,922
| n<sup>3</sup> | 100| 391 | 1,532 | 4,420 | 13,736 | 31,593 | 146,645
| 2<sup>*n*</sup> |19 | 25 | 31 | 36 | 41 | 44 | 51
| *n*! | 9 | 11 | 12 | 13 | 15 | 16 | 17


**running_time_compare.py**

```python
import math


def generate_time_array():
    second = 1000000
    minute = 60 * second
    hour = 60 * minute
    day = 24 * hour
    month = 30 * day
    year = 365 * day
    century = 100 * year
    return [second, minute, hour, day, month, year, century]


def sqrt_n(time):
    return time ** 2


def n(time):
    return time


def n_lg_n(time):
    time_taken, n = 0, 0
    initial_n = 1
    # overshoot the first n
    while time_taken <= time:
        initial_n *= 10
        time_taken = (initial_n * math.log(initial_n, 2))
    # now double back iteratively and determine the specific location
    n = 0
    for x in range(len(str(initial_n))):
        o = initial_n // 10 ** x
        n = n_lg_n_helper(time, o, n)
    return n


def n_lg_n_helper(time, o, n_so_far):
    time_taken = 0
    n = n_so_far
    while time_taken < time:
        n += o
        time_taken = (n * math.log(n, 2))
    return n - o


def n_squared(time):
    time_taken, n = 0, 0
    while time_taken <= time:
        n += 1
        time_taken = n ** 2
    return n-1


def n_cubed(time):
    time_taken, n = 0, 0
    while time_taken <= time:
        n += 1
        time_taken = n ** 3
    return n-1


def two_to_the_n(time):
    time_taken, n = 0, 0
    while time_taken <= time:
        n += 1
        time_taken = 2 ** n
    return n-1


def n_factorial(time):
    time_taken, n = 0, 0
    while time_taken <= time:
        n += 1
        time_taken = math.factorial(n)
    return n-1


time_array = generate_time_array()
time_array_names = ["second", "minute", "hour", "day", "month", "year", "century"]

print("lg(n)")
for i in range(len(time_array_names)):
    print(time_array_names[i] + ": 2^" + str(time_array[i]))

print("sqrt(n)")
for i in range(len(time_array_names)):
    print(time_array_names[i] + ": " + str(sqrt_n(time_array[i])))

print("n")
for i in range(len(time_array_names)):
    print(time_array_names[i] + ": " + str(n(time_array[i])))

print("n lg(n)")
for i in range(len(time_array_names)):
    print(time_array_names[i] + ": " + str(n_lg_n(time_array[i])))

print("n^2")
for i in range(len(time_array_names)):
    print(time_array_names[i] + ": " + str(n_squared(time_array[i])))

print("n^3")
for i in range(len(time_array_names)):
    print(time_array_names[i] + ": " + str(n_cubed(time_array[i])))

print("2^n")
for i in range(len(time_array_names)):
    print(time_array_names[i] + ": " + str(two_to_the_n(time_array[i])))

print("n!")
for i in range(len(time_array_names)):
    print(time_array_names[i] + ": " + str(n_factorial(time_array[i])))
```
